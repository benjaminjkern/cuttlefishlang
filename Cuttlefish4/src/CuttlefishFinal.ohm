Cuttlefish {
    Program = newline? ListOf<Statement, newline> newline?

    Statement =
        | Assignment
        | Reassignment
        | Print
        | If
        | Switch
        | Catch
        | While
        | Repeat
        | For
        | Break
        | Continue
        | Return
        | Put
        
    Assignment =
        | Assignable "=" Expression -- single
        | NonemptyListOf<Assignable, ","> "=" Expression -- multipletoone
        | NonemptyListOf<Assignable, ","> "=" NonemptyListOf<~Function ~Process Expression, ","> -- multiple
    Reassignment =
        | Assignable reassignable ~space "=" Expression
    Print = print Expression
    If = if Expression ":" Block<Statement> (newline else ":"? Block<Statement>)?
    Switch = switch Expression ":" PatternBlock
    Catch = catch ":"? PatternBlock
    For = for Expression ":" PatternBlock
    While = while Expression ":" Block<Statement>
    Repeat = repeat (Expression? ":")? Block<Statement>
    Break = break
    Continue = continue
    Return = return Expression?
    Put = put? Expression
    
   	keyword = print | if | else | catch | while | repeat | for | break | continue | return | put | fn | prc | switch | binaryWord
    print = "print" &sep
    if = "if" &sep
    else = "else" &sep
    switch = "switch" &sep
    catch = "catch" &sep
    for = "for" &sep
    while = "while" &sep
    repeat = "repeat" &sep
    break = "break" &sep
    continue = "continue" &sep
    return = "return" &sep
    put = "put" &sep
    fn = "fn" &sep
    prc = "prc" &sep
    sep = space | reserved | &end | newline

    Assignable = ElementOf | ref

    Expression = 
        | Expression1 "?" Expression1 ":" Expression -- ternary
        | Expression1

    Expression1 =
        | Expression1 #(space binaryWord &sep) Expression2 -- explicitsep
        | Expression1 binaryWord &sep Expression2 -- implicitsep
        | Expression1 binaryOp Expression2 -- operator
        | Expression2
        
    Expression2 =
        | Expression2 Expression3 -- application
        | Expression2 Block<Expression> -- block
        | Expression3

    Expression3 =
        | Expression4 #(~space &sep) Expression -- nospaceapplication
        | Expression4

    Expression4 =
        | unaryOp #(~space) Expression4 -- operator
        | ElementOf
        | Atom

    Atom =
        | "(" Expression ")" -- group
        | List
        | DiscreteRange
        | ContinuousRange
        | Tuple
        | Set
        | Function
        | Process
        | String
        | number
        | ref

    reassignable = "*" | "//" | "/"  | "^" | "++" | "+" | "-" | "%" | "|" | "&"

    binaryWord = "in" | "and" | "or"

    binaryOp = "===" | "!==" | "==" | "!=" | ">=" | "<=" | ">" | "<" | "%=" | "||" | "&&" | "|>" | reassignable
    
    unaryOp = "-" | "!"

    reserved = binaryOp | unaryOp | "=" | "." | "," | "(" | ")" | "{" | "}" | "[" | "]" | ":" | ".." | "→" | "←" | "?" | ";" | "\"" | "'" | "`"
    ref = ~number ~keyword (~reserved ~space ~newline any)+
    
    DiscreteRange = ("[" | "(") Expression ".." (Expression "..")? Expression? (")" | "]")
    ContinuousRange = ("[" | "(") Expression "..." Expression? (")" | "]")

    ElementOf = Expression3 #(~space) "." #(~space) ref

    Tuple = "(" ListOf<Expression, ","> ","? ")"
    List = "[" ListOf<Expression, ","> ","? "]"
    Set = "{" ListOf<Expression, ","> ","? "}"
    // MatchSet = "{" Block<PatternElem Guard?> "}"
    // need to put this in at some point but this requires breaking down guards and patterns

    Function = fn ":" PatternBlock
    Process = prc ":" PatternBlock

    PatternBlock =
        | Block<Pattern> -- pattern
        | Block<Statement> -- statement
    Pattern =
        | NonemptyListOf<PatternElem, ","> Block<Guard> -- guard
        | NonemptyListOf<PatternElem, ","> Returnbit -- return
    Guard =
        | "|" Expression Block<Guard> -- guard
        | "|" Expression? Returnbit -- return
    Returnbit = "->" Block<~Pattern Statement>

    PatternElem = TypeMatch ("=" Expression)? -- anonymous
        | ~ref Atom -- specific
    patternModifier = "*" | "?" | "+"
    TypeMatch =
        | Expression4 (#(~space) patternModifier)? ref -- typed
        | ref -- untyped

    Block<Inside> = NonemptyListOf<Inside, ";"> -- single
    	| newline "→" newline ListOf<Inside, newline> newline "←" -- indented
    	| indentnewline? "{" indentnewline? ListOf<Inside, newline> indentnewline? "}" -- forced
    indentnewline =
        | newline ("→"|"←") newline -- indented
        | newline
    String = string<"'"> | string<"\"">
    	| "`" ListOf<#(stringbit), StringExp> "`" -- expression

    stringbit = ("\\`" | "\\{" | ~"`" ~"{" any)*
    StringExp = "{" Expression "}"
    
    number = "-"? digit+ ("." digit+)? (("e" | "E") ("-" | "+")? digit+)?
    string<delim> = delim (escape<delim> | ~delim any)* delim
    escape<delim> = "\\" delim
    comment = "###" (~"###" any)* ("###"|&end) | "#" (~newline any)* (&newline|&end)
    newline = ("\n" | "\r" | ";") (space* ("\n" | "\r" | ";"))*
    space := ~newline ("\u0000".." "  | comment)
}