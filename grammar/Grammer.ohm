Cuttlefish {
   Specification = newline* Statement (newline Statement)* newline*

   Statement = 
    | AssignmentStatement
    | "print" Expression -- print
    | "put"? Expression -- put
    
   Block<A, delimiter> =
    | A (delimiter A)* &newline? -- small
    | newline indent newline* A ((newline|delimiter) A)* newline* delimiter? dedent -- large
    
   AssignmentStatement =
    | Pattern ":=" SubRoutineGroup -- functionAssignment
    | Pattern "=" Expression -- regularAssignment

   Pattern = NonemptyListOf<PatternElement,",">
   PatternElement = 
    | Sequence<"(",")"> -- patternTuple
    | ListType? Atom ":" id -- patternList
    | Type Atom -- type
    | Atom
   Type = Type "=>" Type -- functionType
    | ListType
    | id
   ListType = "[" Type "]"
   
   
   SubRoutineGroup = Block<SubRoutine, ";"> | Block<Statement, ",">

   Routine = Function | Process | Server
   Function = "fn" ":" SubRoutineGroup
   Process = "prc" ":" SubRoutineGroup
   Server = "srv" ":" SubRoutineGroup
   
   SubRoutine = Pattern "->" Block<Statement, ",">

   Expression =
    | Atom+ -- call

   Atom =
    | "(" Expression ")" -- singleton
    | "()"
    | AbstractType
    | Routine
    | Select
    | List
    | String
    | Tuple
    | numlit 
    | nospaceops 
    | id 

   AbstractType = "type" ("(" id ")")? (":" Block<Pattern, ",">)?
    
   Select = (List | Tuple | String | DynamicSequence | id) "[" (Function | numlit) "]"

   Tuple = "(" (Atom ",")+  Atom? ")"
   List =
    | "[" Atom ".." (Atom "..")? Atom? "]" -- numlist
    | Sequence<"[","]">
   String = rawSequence<"\"","\"">
    | rawSequence<"\'","\'">
    | rawSequence<"`","`">
   numlit = digit+ ("." digit+)? (("E" | "e") ("+" | "-")? digit+)?

   indent = "⇨"
   dedent = "⇦"
	
   nospaceops = dynamicnospaceops | "~" | "+" | "++" | ">=" | "<=" | "!=" | "==" | "===" | "*"
   keyword = "fn" | "prc" | "srv" | "put" | "print"
   reserved = keyword | nospaceops | "(" | ")" | "," | "[" | "]" | "->" | "=>" | ":" | ":=" | "=" | ".." | "#" | ";" | "\n" | indent | dedent
   id = (~reserved ~space any)+

   dynamicnospaceops = "FOR COMPILE TIME USE"
   DynamicRawSequence = "FOR COMPILE TIME USE"
   DynamicSequence = "FOR COMPILE TIME USE"

   newline =  ("\n" comment?)+
   space :=  " " | "\t" | comment
   comment =  "#" (~"\n" any)* -- normalComment
    | rawSequence<"#/","/#">

   Sequence<open,close> = open ListOf<Atom,","> close
   rawSequence<open,close> = open (~open ~close any)*  close
}